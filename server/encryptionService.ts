import crypto from "crypto"; // Encryption configurationconst ALGORITHM = "aes-256-gcm";const IV_LENGTH = 16;const SALT_LENGTH = 32;const TAG_LENGTH = 16;const KEY_LENGTH = 32;const ITERATIONS = 100000;interface EncryptedData {  encrypted: string;  iv: string;  authTag: string;  salt?: string;  keyVersion?: number;}interface EncryptionMetadata {  algorithm: string;  keyVersion: number;  encrypted: boolean;}class EncryptionService {  private masterKey!: Buffer; // ✅ Fixed TS2564  private deterministicKey!: Buffer; // ✅ Fixed TS2564  private currentKeyVersion: number = 1;  constructor() {    this.initializeKeys();  }  private initializeKeys() {    const masterKeyHex = process.env.ENCRYPTION_MASTER_KEY || this.generateKey();    const deterministicKeyHex = process.env.ENCRYPTION_DETERMINISTIC_KEY || this.generateKey();    if (!process.env.ENCRYPTION_MASTER_KEY) {      process.env.ENCRYPTION_MASTER_KEY = masterKeyHex;      console.log("Generated new master encryption key");    }    if (!process.env.ENCRYPTION_DETERMINISTIC_KEY) {      process.env.ENCRYPTION_DETERMINISTIC_KEY = deterministicKeyHex;      console.log("Generated new deterministic encryption key");    }    this.masterKey = Buffer.from(masterKeyHex, "hex");    this.deterministicKey = Buffer.from(deterministicKeyHex, "hex");    this.currentKeyVersion = parseInt(process.env.ENCRYPTION_KEY_VERSION || "1");  }  private generateKey(): string {    return crypto.randomBytes(KEY_LENGTH).toString("hex");  }  encrypt(data: any): EncryptedData | null {    if (data === null || data === undefined) return null;    try {      const text = typeof data === "string" ? data : JSON.stringify(data);      const iv = crypto.randomBytes(IV_LENGTH);      const cipher = crypto.createCipheriv(ALGORITHM, this.masterKey, iv);      let encrypted = cipher.update(text, "utf8", "hex");      encrypted += cipher.final("hex");      const authTag = cipher.getAuthTag();      return {        encrypted,        iv: iv.toString("hex"),        authTag: authTag.toString("hex"),        keyVersion: this.currentKeyVersion,      };    } catch (error) {      console.error("Encryption error:", error);      throw new Error("Failed to encrypt data");    }  }  decrypt(encryptedData: EncryptedData): any {    if (!encryptedData || !encryptedData.encrypted) return null;    try {      const iv = Buffer.from(encryptedData.iv, "hex");      const authTag = Buffer.from(encryptedData.authTag, "hex");      const key = this.getKeyForVersion(encryptedData.keyVersion || 1);      const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);      decipher.setAuthTag(authTag);      let decrypted = decipher.update(encryptedData.encrypted, "hex", "utf8");      decrypted += decipher.final("utf8");      try {        return JSON.parse(decrypted);      } catch {        return decrypted;      }    } catch (error) {      console.error("Decryption error:", error);      throw new Error("Failed to decrypt data");    }  }  encryptDeterministic(data: string): EncryptedData | null {    if (data === null || data === undefined) return null;    try {      const text = data.toString();      const hmac = crypto.createHmac("sha256", this.deterministicKey);      hmac.update(text);      const ivSource = hmac.digest();      const iv = ivSource.slice(0, IV_LENGTH);      const cipher = crypto.createCipheriv(ALGORITHM, this.deterministicKey, iv);      let encrypted = cipher.update(text, "utf8", "hex");      encrypted += cipher.final("hex");      const authTag = cipher.getAuthTag();      return {        encrypted,        iv: iv.toString("hex"),        authTag: authTag.toString("hex"),        keyVersion: this.currentKeyVersion,      };    } catch (error) {      console.error("Deterministic encryption error:", error);      throw new Error("Failed to encrypt data deterministically");    }  }  decryptDeterministic(encryptedData: EncryptedData): string | null {    if (!encryptedData || !encryptedData.encrypted) return null;    try {      const iv = Buffer.from(encryptedData.iv, "hex");      const authTag = Buffer.from(encryptedData.authTag, "hex");      const decipher = crypto.createDecipheriv(ALGORITHM, this.deterministicKey, iv);      decipher.setAuthTag(authTag);      let decrypted = decipher.update(encryptedData.encrypted, "hex", "utf8");      decrypted += decipher.final("utf8");      return decrypted;    } catch (error) {      console.error("Deterministic decryption error:", error);      throw new Error("Failed to decrypt deterministic data");    }  }  hashForSearch(data: string): string {    if (!data) return "";    const hmac = crypto.createHmac("sha256", this.deterministicKey);    hmac.update(data.toLowerCase().trim());    return hmac.digest("hex");  }  private getKeyForVersion(version: number): Buffer {    if (version === 1) {      return this.masterKey;    }    throw new Error(`Unknown key version: ${version}`);  }  rotateKeys(): void {    const newMasterKey = this.generateKey();    const newDeterministicKey = this.generateKey();    process.env.ENCRYPTION_MASTER_KEY = newMasterKey;    process.env.ENCRYPTION_DETERMINISTIC_KEY = newDeterministicKey;    process.env.ENCRYPTION_KEY_VERSION = (this.currentKeyVersion + 1).toString();    this.initializeKeys();    console.log(`Keys rotated to version ${this.currentKeyVersion}`);  }  getMetadata(): EncryptionMetadata {    return {      algorithm: ALGORITHM,      keyVersion: this.currentKeyVersion,      encrypted: true,    };  }  encryptObject(obj: any, fieldsToEncrypt: string[], deterministicFields: string[] = []): any {    if (!obj) return obj;    const encrypted = { ...obj };    for (const field of fieldsToEncrypt) {      if (obj[field] !== undefined && obj[field] !== null) {        const encryptedData = deterministicFields.includes(field)          ? this.encryptDeterministic(obj[field])          : this.encrypt(obj[field]);        if (encryptedData) {          encrypted[field] = JSON.stringify(encryptedData);        }      }    }    return encrypted;  }  decryptObject(obj: any, fieldsToDecrypt: string[], deterministicFields: string[] = []): any {    if (!obj) return obj;    const decrypted = { ...obj };    for (const field of fieldsToDecrypt) {      if (obj[field] && typeof obj[field] === "string") {        try {          const encryptedData = JSON.parse(obj[field]);          if (encryptedData.encrypted) {            decrypted[field] = deterministicFields.includes(field)              ? this.decryptDeterministic(encryptedData)              : this.decrypt(encryptedData);          }        } catch {          decrypted[field] = obj[field]; // Fallback if not encrypted        }      }    }    return decrypted;  }  isEncrypted(value: any): boolean {    if (!value || typeof value !== "string") return false;    try {      const parsed = JSON.parse(value);      return !!(parsed.encrypted && parsed.iv && parsed.authTag);    } catch {      return false;    }  }}// Export singleton instanceexport const encryptionService = new EncryptionService();// PHI field definitions for each tableexport const PHI_FIELDS = {  donors: {    fields: ["age", "weight", "height", "medicalHistory", "hlaType", "location"],    deterministicFields: ["location"],  },  recipients: {    fields: ["firstName", "lastName", "medicalData", "hlaType", "antibodies", "location"],    deterministicFields: ["firstName", "lastName", "location"],  },  messages: {    fields: ["content"],    deterministicFields: [],  },  custodyLogs: {    fields: ["notes"],    deterministicFields: [],  },};
