// server/middleware/sessionMiddleware.tsimport { Request, Response, NextFunction } from "express";import jwt, { JwtPayload } from "jsonwebtoken";const JWT_SECRET = process.env.JWT_SECRET || "changeme";const REFRESH_SECRET = process.env.REFRESH_SECRET || "refreshchangeme";export const ACCESS_TOKEN_EXPIRY = "15m"; // short-livedexport const REFRESH_TOKEN_EXPIRY = "7d"; // long-lived// In-memory store (replace with Redis/DB in prod)const validRefreshTokens = new Set<string>();// ---- Token Helpers ----export function generateTokens(payload: object) {  const accessToken = jwt.sign(payload, JWT_SECRET, {    expiresIn: ACCESS_TOKEN_EXPIRY,  });  const refreshToken = jwt.sign(payload, REFRESH_SECRET, {    expiresIn: REFRESH_TOKEN_EXPIRY,  });  // Track refresh token  validRefreshTokens.add(refreshToken);  return { accessToken, refreshToken };}// ---- Middleware: validate refresh token ----export function authenticateRefreshToken(  req: Request,  res: Response,  next: NextFunction) {  const token = req.cookies?.refreshToken;  if (!token) {    return res.status(401).json({ message: "Missing refresh token" });  }  if (!validRefreshTokens.has(token)) {    return res.status(403).json({ message: "Refresh token revoked or reused" });  }  try {    const payload = jwt.verify(token, REFRESH_SECRET) as JwtPayload;    // Rotate token: remove old, issue new    validRefreshTokens.delete(token);    const { refreshToken, accessToken } = generateTokens(payload);    // Set new refresh token cookie    res.cookie("refreshToken", refreshToken, {      httpOnly: true,      secure: process.env.NODE_ENV === "production",      sameSite: "strict",      maxAge: 7 * 24 * 60 * 60 * 1000,    });    // Attach for downstream usage    (req as any).refreshUser = payload;    (req as any).newAccessToken = accessToken;    next();  } catch (err) {    return res.status(403).json({ message: "Invalid or expired refresh token" });  }}// ---- Logout Helper ----export function revokeRefreshToken(token: string) {  validRefreshTokens.delete(token);}
